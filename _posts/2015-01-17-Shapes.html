---
layout: post
title:  "Shapes"
date:   2015-01-17 00:34:17
categories: jekyll update
reference: http://www.storminthecastle.com/2013/07/24/how-you-can-draw-regular-polygons-with-the-html5-canvas-api/
---

<fieldset>
  <legend>Variables</legend>
Sides: <input data-bind="value: numberOfSides, valueUpdate: 'afterkeydown'" class="largeNumberTextBox"/>
<div style="margin: 10px" data-bind="slider: numberOfSides, sliderOptions: {min: 0, max: 20, range: 'min', step: 1}"></div>
</fieldset>

<canvas id="canvas" width="300" height="300"></canvas>
<script>

function polygon(ctx, x, y, radius, sides, startAngle, anticlockwise) {
  if (sides < 3) {
      DrawSadFace(ctx);
      return;
  }
  var a = (Math.PI * 2)/sides;
  a = anticlockwise?-a:a;
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(startAngle);
  ctx.moveTo(radius,0);
  for (var i = 1; i < sides; i++) {
    ctx.lineTo(radius*Math.cos(a*i),radius*Math.sin(a*i));
  }
  ctx.closePath();
  ctx.restore();
}

var canvas = document.getElementById("canvas");
var context = canvas.getContext("2d");
context.lineWidth = 5;
context.strokeStyle = 'black';

// context.beginPath();
// polygon(context,125,125,100,5,-Math.PI/2);
// context.fillStyle="rgba(227,11,93,0.75)";
// context.fill();
// context.stroke();

// Draw a circle to encompass this polygon
/*
context.beginPath();
context.arc(125, 125, 100, 0, Math.PI * 2);
context.stroke();

context.beginPath();
polygon(context,350,125,100,6,-Math.PI/2);
context.fillStyle="rgba(51,128,255,0.75)";
context.fill();
context.stroke();

context.beginPath();
polygon(context,125,350,100,7,-Math.PI/2);
context.fillStyle="rgba(11,227,93,0.75)";
context.fill();
context.stroke();

context.beginPath();
polygon(context,350,350,100,8,0,false);
polygon(context,350,350,60,8,0,true);
context.fillStyle="rgba(227,11,93,0.75)";
context.shadowColor = 'rgba(0,0,0,0.75)';
context.shadowOffsetX = 8;
context.shadowOffsetY = 8;
context.shadowBlur = 10;
context.fill();
*/

function Redraw(sides)
{
  context.clearRect ( 0 , 0 , canvas.width, canvas.height );
  context.beginPath();
  polygon(context,150,150,100,sides,-Math.PI/2);
  context.fillStyle="rgba(227,11,93,0.75)";
  context.fill();
  context.stroke();
}

function DrawSadFace(context)
{
  context.clearRect ( 0 , 0 , canvas.width, canvas.height );
  // The Face
  var centerX = canvas.width / 2;
  var centerY = canvas.height / 2;
  var radius = 70;
  var eyeRadius = 10;
  var eyeXOffset = 25;
  var eyeYOffset = 20;

  // draw the yellow circle
  context.beginPath();
  context.arc(centerX, centerY, radius, 0, 2 * Math.PI, true);
  context.fillStyle = 'yellow';
  context.fill();
  context.stroke();

  // draw the eyes
  context.beginPath();
  var eyeX = centerX - eyeXOffset;
  var eyeY = centerY - eyeXOffset;
  context.arc(eyeX, eyeY, eyeRadius, 0, 2 * Math.PI, false);
  var eyeX = centerX + eyeXOffset;
  context.arc(eyeX, eyeY, eyeRadius, 0, 2 * Math.PI, false);
  context.fillStyle = 'black';
  context.fill();


  // draw the mouth
  context.beginPath();
  context.arc(centerX, centerY+40, 30, 2*Math.PI, Math.PI, true);
  context.stroke();
}
</script>


<script>
ko.bindingHandlers.slider = {
  init: function (element, valueAccessor, allBindingsAccessor) {
    var options = allBindingsAccessor().sliderOptions || {};
    $(element).slider(options);
    ko.utils.registerEventHandler(element, "slidechange", function (event, ui) {
      var observable = valueAccessor();
      observable(ui.value);
    });
    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
      $(element).slider("destroy");
    });
    ko.utils.registerEventHandler(element, "slide", function (event, ui) {
      var observable = valueAccessor();
      observable(ui.value);
    });
  },
  update: function (element, valueAccessor) {
    var value = ko.utils.unwrapObservable(valueAccessor());
    if (isNaN(value)) value = 0;
    $(element).slider("value", value);

  }
};


var ViewModel = function() {
  var self = this;

  self.numberOfSides = ko.observable(3);
  self.spent = ko.observable(3);
  self.net = ko.computed(function() {
            Redraw(self.numberOfSides());
    return self.numberOfSides() - self.spent();
  });
}

ko.applyBindings(new ViewModel());

</script>
